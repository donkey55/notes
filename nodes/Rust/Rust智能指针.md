# Rust智能指针

> 在Rust中创建引用的行为被称为借用

## Box指针

`Box<T>`指针是将一个类型进行包装，将类型的值存储在堆上，而将指向其地址的指针存储在栈上。

### Deref Trait

在这里，对于我们平时定义的一个struct类型，比如

```rust
struct A {
    i: i32;
}
let a = A(2);
```

在这里A类型，我们不可以将其当作指针使用，即我们需要先获得a的引用 &a，然后才可以对其进行解引用的操作。

而通过为A实现`Deref Trait`能够让我们直接进行`*a`来对其进行解引用的操作。

### Deref强制类型转换

类似于如何使用 `Deref` trait 重载不可变引用的 `*` 运算符，Rust 提供了 `DerefMut` trait 用于重载可变引用的 `*` 运算符。

Rust 在发现类型和 trait 实现满足三种情况时会进行 Deref 强制转换：

- 当 `T: Deref<Target=U>` 时从 `&T` 到 `&U`。
- 当 `T: DerefMut<Target=U>` 时从 `&mut T` 到 `&mut U`。
- 当 `T: Deref<Target=U>` 时从 `&mut T` 到 `&U`。

头两个情况除了第二种实现了可变性之外是相同的：第一种情况表明如果有一个 `&T`，而 `T` 实现了返回 `U` 类型的 `Deref`，则可以直接得到 `&U`。第二种情况表明对于可变引用也有着相同的行为。

第三个情况有些微妙：Rust 也会将可变引用强转为不可变引用。但是反之是 **不可能** 的：不可变引用永远也不能强转为可变引用。因为根据借用规则，如果有一个可变引用，其必须是这些数据的唯一引用（否则程序将无法编译）。将一个可变引用转换为不可变引用永远也不会打破借用规则。将不可变引用转换为可变引用则需要初始的不可变引用是数据唯一的不可变引用，而借用规则无法保证这一点。因此，Rust 无法假设将不可变引用转换为可变引用是可能的。

### Drop Trait

和C++中的析构函数差不多

## Rc指针



## RefCell指针
